seed_everything: 42
ckpt_path: null # only set if you want to load a checkpoint AND optimizer state

model:
  class_path: cc2CRPS_L.cc2CRPSModel
  init_args:
    input_resolution: &input_resolution_anchor '[97, 86]'
    hidden_dim: 128
    num_heads: 8
    encoder2_depth: 2
    decoder1_depth: 2
    learning_rate: 1e-3
    patch_size: 2
    window_size: 8
    add_skip_connection: true
    prognostic_params: &prognostic_params_anchor
    - tcc
    forcing_params: &forcing_params_anchor
    - insolation
    - t_1000
    - t_500
    - t_700
    - t_850
    - t_925
    - u_1000
    - u_500
    - u_700
    - u_850
    - u_925
    - v_1000
    - v_500
    - v_700
    - v_850
    - v_925
    - z_1000
    - z_500
    - z_700
    - z_850
    - z_925

    # Path to checkpoint for initializing ONLY model weights (starts epoch 0, new optimizer)
    init_weights_from_ckpt: false # Set path here or via CLI: --model.init_weights_from_ckpt=true
    # Adapt resolution when using init_weights_path
    adapt_ckpt_resolution: false # Set true here or via CLI: --model.adapt_ckpt_resolution=true
data:
  input_resolution: *input_resolution_anchor
  data_path: ../data/era5-86x97.zarr
  prognostic_params: *prognostic_params_anchor
  forcing_params: *forcing_params_anchor
  batch_size: 16

trainer:
  max_epochs: 25
  logger:
  - class_path: lightning.pytorch.loggers.MLFlowLogger
    init_args:
      experiment_name: "cc2"
      log_model: true
      save_dir: "./mlruns"
  enable_model_summary: false
  accumulate_grad_batches: 1
  num_nodes: 1
  devices: 1
  strategy: auto
  callbacks:
  - class_path: lightning.pytorch.callbacks.ModelCheckpoint
    init_args:
      monitor: "val_loss"
      mode: "min"
      save_last: true

  - class_path: pgu.callbacks.PredictionPlotterCallback

  - class_path: pgu.callbacks.DiagnosticCallback 
    init_args:
      check_frequency: 50

  - class_path: lightning.pytorch.callbacks.ModelSummary
    init_args:
      max_depth: 2

  - class_path: pgu.callbacks.CleanupFailedRunCallback
